# 026. 멀티플렉싱과 소켓
### ■ 멀티플렉싱과 디멀티플렉싱
![ 멀티플렉싱과 디멀티플렉싱]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_01.PNG)
<br><br>
&nbsp;전송 계층의 기본 기능인 멀티플렉싱(Multiplexing)에 대해서 알아보자. 하나의 컴퓨터에는 여러 개의 프로그램 또는 여러 개의 프로세스가 동작하고 있다. 인터넷 브라우저도 통신을 하고 메일 프로그램이나 메신저 프로그램도 통신을 한다. 프로그램들은 각각의 통신 기능을 제공하지만 결국에는 네트워크 계층, 링크 계층, 물리 계층으로 내려가면 하나의 회선, 하나의 주파수 채널로 전송이 되어야 한다. 어떤 프로세스에서 내려 왔던 간에 하나의 공통 링크를 통해서 전송이 되어야 하는 것이다.
<br><br>
&nbsp;그래서 멀티플렉싱이라는 것은 데이터를 보내는 쪽에서 여러 개의 프로그램이나 프로세스가 동시에 작동하고 있는데 이것에서 동시에 내려오는 데이터들을 공유하고 있는 하나의 동일한 회선을 통해서 전달하고자 하는 것이다. 좀 더 요약하면 여러 서비스들을 동시에 하나의 링크로 내보내는 다중화라고 할 수 있다.
<br><br>
&nbsp; 반대로 이렇게 섞여서 송신된 데이터들은 목적지 컴퓨터에 도달하게 되면 각각의 목적지에 맞는 프로세스로 나뉘어서 전달이 되어야 한다. 이것을 역다중화, 영어로는 디멀티플렉싱(Demultiplexing)이라고 한다. 
<br>
### ■ 멀티플렉싱과 디멀티플렉싱을 제공하는 전송 계층
![멀티플렉싱과 디멀티플렉싱을 제공하는 전송 계층]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_02.PNG)
<br><br>
&nbsp;멀티플렉싱과 디멀티플렉싱은 전송 계층에서 프로세스들 간의 논리적인 연결을 위해 제공한다.
<br><br>
&nbsp;그림을 보면 왼쪽을 1번 클라이언트, 중앙을 서버, 오른쪽을 2번 클라이언트라고 가정하자. 1번 클라이언트가 프로세스 P3를 실행시켜 서버의 P1 프로세스와 통신을 한다. 마찬가지로 2번 클라이언트는 P4 프로세스를 실행시켜서 중앙 서버에 접속하여 P2 프로세스와 통신을 한다. 서버 입장에서는 데이터를 자기가 생성해서 내보낼 때 P1이 전송하는 데이터인지, P2가 전송하는 데이터인지 구분해서 하나의 링크로 내보내야 하는 기능이 필요한데 이것이 멀티플렉싱이다.
<br><br>
&nbsp;반대로 1번 클라이언트가 보내오는 데이터나 2번 클라이언트가 보내오는 데이터는 똑 같은 물리적 채널을 통해서 서버에 들어오게 된다. 물리 계층과 링크 계층까지는 1번과 2번 클라이언트의 데이터가 같이 전송이 되어지다가 전송 계층에서 분리가 되어 P3 프로세스의 내용은 P1 프로세스에게, P4 프로세스의 내용은 P2 프로세스에게 나누어서 전달이 된다. 이것이 디멀티플렉싱이다. 
<br>
### ■ 디멀티플렉싱이 어떻게 작동하는가
![디멀티플렉싱이 어떻게 작동하는가]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_03.PNG)
<br><br>
&nbsp;앞의 설명에서 서버가 받는 데이터가 1번 클라이언트에서 보낸 것인지, 2번 클라이언트에서 보낸 것인지 구별할 수 있는 정보가 전송 계층에서 제공이 되어야 한다. 이 정보를 포트 넘버(Port number)라고 한다.
<br><br>
&nbsp;포트 넘버에서 포트(Port)는 항구, 부두라는 의미로 어떤 항구로 들어오느냐에 따라 선적 화물이 구별이 되듯이 데이터 또한 마찬가지이다. 컴퓨터에서 애플리케이션들은 각각 서로 다른 포트 넘버를 할당 받게 된다. 그리고 전송 계층의 Segment들은 포트 넘버를 가지는 특별한 필드가 있다. TCP와 UDP 모두 공통적으로 맨 첫 번째에 위치한 것이 포트 넘버이다. 이 포트 넘버가 서로 다른 애플리케이션이나 서로 다른 역할을 하는 프로세스들에게 각각의 포트 넘버를 할당해서 구별할 수 있게 만드는 것이다. 그래서 포트 넘버가 다르면 서로 다른 프로세스에 도착해야 하는 데이터임을 알 수 있다.
<br><br>
&nbsp;결국 전송 계층 필드에 각 응용 프로그램에 대한 포트 넘버를 담아주게 되는데 이것은 컴퓨터가 직접하는 것이 아닌 응용 프로그램이 지시를 하게 된다. 앞의 그림에서 본 것처럼 P3 프로세스가 P1 프로세스와 통신을 하고 싶다면 P1의 포트 넘버를 담아주어야 하는 것이고 그것은 전송 계층이 직접 할 수 있는 것이 아니라 응용 프로그램이 전송 계층에 지시를 내려야 한다. 그리고 이 지시는 소켓(Socket)이라는 것을 통해서 이루어진다.
<br>
### ■ 소켓
![소켓]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_04.PNG)
<br><br>
&nbsp;개발자가 어떤 게임 프로그램을 만든다고 해보자. 개발자는 게임에 메신저 기능이 들어갈 경우 게임을 개발하는 것만으로도 벅찬데 메시지 데이터를 보내기 위해서 어떻게 데이터가 전송되어야 하는지 일일히 기능을 구현하기 힘들 것이다. 그래서 보통 운영체제들은 전송 계층과 애플리케이션 계층 사이에 어떤 API(Application Program Interface)를 제공한다. API를 애플리케이션이 호출하면 API 함수에 원하는 데이터와 목적지 주소를 넣고 하위 계층들이 데이터를 전송해준다. 
<br><br>
&nbsp;이렇게 운영체제에서 제공하는 API들의 집합이 여러 가지가 있는데 이런 것들을 묶어서 소켓(Socket)이라고 이야기한다. 프로세스들은 소켓 인터페이스를 통해서 자신의 데이터를 송신하거나 수신한다. 예를 들어, 집에 있는 전구를 끼우는 소켓을 떠올려보자. 집에 불을 밝히고 싶으면 원하는 전구를 사서 소켓에 끼우기만 하면 된다. 이렇게만 해도 불이 들어오는 이유는 건물을 짓는 사람들이 전력 회사에서 들어오는 전선을 소켓까지 연결을 해놓았기 때문이다. 그래서 규격에 맞는 전구를 사다가 끼우기만 하면 전구를 사용해서 불을 밝힐 수 있다. 마찬가지로 개발자도 API가 제공하는 매개변수(Parameter)의 규격에 맞게끔 데이터를 넣어주면 손쉽게 데이터를 송신할 수 있다.
<br>
### ■ 소켓 프로그램
![소켓 프로그램]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_05.PNG)
<br><br>
&nbsp;위의 그림은 소켓 프로그램을 나타낸 것으로 파이썬으로 구현되었다. 소켓을 사용하려고 하면 소켓이라는 모듈을 import 해야 하고 서버 쪽에서는 자신의 프로세스를 만들고 그 소켓에다가 주소를 할당해놓았다. 위의 예시 그림에서는 자신의 컴퓨터에서 로컬하게 돌아가는 서버와 클라이언트이기 때문에 127.0.0.1이라는 자신을 가리키는 주소를 할당하였다. 이 주소는 다른 말로 로컬 호스트(Localhost)라고 불리기도 한다. 클라이언트 측 소켓 프로그램에는 로컬 호스트로 표기해놓았다.
<br><br>
&nbsp;서버 측 소스코드를 보면 accept라는 것이 있고 recv(receive)라는 것이 있다. 클라이언트 측 소스코드를 보면 그에 상응하는 connect와 send를 확인할 수 있다. 이것은 클라이언트에서 connect를 통해 연결을 수립하겠다는 의미이다. TCP에서는 connection을 먼저 수립하고 데이터를 보내기 때문에 connect라는 것을 통해 클라이언트가 서버에 연결을 요청하는 것이다. 클라이언트 측 소스코드의 connect 뒤에 오는 매개변수는 해당 로컬 호스트 인터넷 주소를 가진 프로세스들 중에서 포트 넘버 8089라는 프로세스와 연결을 하겠다는 의미이다. 그러면 서버는 작동하고 있다가 클라이언트의 요청이 도착하면 해당 요청이 bind된 주소와 포트 넘버가 일치할 경우 accept한다. 그러면 연결이 수립된다.
<br><br>
&nbsp;연결이 수립되고 나면 클라이언트는 데이터를 send 할 수 있다. 클라이언트 측 소스코드의 send 뒤에는 Get / Index.html이라고 되어 있는데 이것이 HTTP 프로토콜의 가장 첫 번째로 나오는 내용이 된다. 수신자인 서버는 이것을 받아서 처리하게 되는데, 해당 메시지가 GET INDEX이기 때문에 뒤에 표기된 사이트의 정보를 클라이언트에게 보내주게 된다.
<br><br>
&nbsp;간단하게 정리하면 먼저 소켓을 서버에서 생성하고 그 다음에 클라이언트가 보내 온 연결 요청을 accept하면 연결이 수립된다. 그리고 클라이언트가 보내 온 데이터를 receive해서 해당 요청에 맞는 응답을 보내주는 식으로 통신이 진행된다.
### ■ 디멀티플렉싱의 예
![디멀티플렉싱의 예]( https://raw.githubusercontent.com/taechacode/ComputerScienceRepository/master/Computer%20Network/images/CN_026_06.PNG)
<br><br>
&nbsp;위의 그림에서 왼쪽은 A라는 IP 주소를 가진 호스트이고, 중앙은 B라는 IP 주소를 가진 서버이고, 오른쪽은 C라는 IP 주소를 가진 호스트이다. 먼저 A라는 호스트에서 P3라는 프로세스가 서버에게 데이터를 전송하게 되는데 이 데이터에는 보내는 소스 IP는 A, 포트 넘버는 9157이라고 되어 있다. 목적지 주소는 B이고 포트 넘버는 80이라고 되어 있다. 그러면 B라는 서버에 80번 포트를 찾아서 전송을 하게 되고 여기서는 P4 프로세스가 데이터를 수신 받게 된다. P4 프로세스 또한 수신 받은 데이터에 대한 응답을 보내주게 되고 그 데이터에는 목적지 주소가 A와 포트 넘버 9157로 되어 있다. A라는 호스트의 포트 넘버 9157이 할당된 프로세스 P3에게 데이터가 전달되는 것이다.
<br><br>
&nbsp;오른쪽의 C 호스트도 마찬가지이다. P2 프로세스의 경우 포트 넘버는 5775이고 컴퓨터의 IP 주소는 C이다. 그래서 보내는 메시지를 보면 소스에 C와 5775가 표기되어 있다. 목적지 주소는 B 서버로 되어 있고 포트 넘버는 8089로 되어 있다. 그래서 8089 포트 넘버로 동작하고 있는 B 서버의 P6 프로세스가 데이터를 수신 받는다. 그리고 A 호스트 사례와 마찬가지로 서버로부터 P2 프로세스는 P6 프로세스로부터 응답을 받을 것이다.
<br><br>
&nbsp;그런데 하나의 컴퓨터 내에 동일한 포트 넘버를 가지는 프로세스가 2개 이상 있을 수 있을까? 있을 수 있다. 위에서 C라는 호스트의 P3 프로세스가 B 서버의 P5 프로세스에게 데이터를 보낸다. 그런데 목적지의 포트 넘버를 보면 80이라고 되어 있다. 80 포트는 보통 웹 서버 프로그램이 사용하는데, 이 웹 서버는 하나의 클라이언트가 접속할 때마다 똑같은 프로세스를 여러 개 띄우게 된다. C뿐만 아니라 A라는 클라이언트에게 제공할 서비스를 하기 위한 프로세스인 P4 프로세스도 존재한다. 동일한 프로세스를 띄우다 보니 포트 넘버도 동일하게 할당되는데 그래서 P4와 P5 프로세스 모두 포트 넘버가 80으로 되어 있는 것을 위 그림을 통해 알 수 있다. 그렇다면 어떻게 포트 넘버가 같은 P4와 P5 프로세스를 구분해서 데이터를 전달할 수 있을까?
<br><br>
&nbsp;이런 현상은 Connection-oriented 프로토콜에서만 나타난다. Connection-oriented 프로토콜은 데이터를 보내기 전에 connection을 먼저 수립한다. connection에서는 수신자의 IP나 포트 넘버 외에도 송신자의 IP와 포트 넘버도 구별하는 인자로 사용한다. 그래서 A의 P3 프로세스가 보내는 데이터와 C의 P3 프로세스가 보내는 데이터를 살펴보면 다른 항목들은 모두 일치하는데 보내는 소스 IP가 다름을 알 수 있다. 그래서 B 서버의 P4와 P5 프로세스가 동일하게 80번 포트를 쓴다고 해도 이미 connection으로 구별되어 있기 때문에 나누어서 전달할 수 있는 것이다. 그래서 디멀티플렉싱을 할 때 포트 넘버만으로 구분되는 것은 아니라는 것을 알 수 있다.
<br><br><br>
###### <span style="color:#666666">※ 본 정리 내용은 부산대학교 유영환 교수님의 컴퓨터 네트워킹 수업을 정리한 것입니다.<br>※※ 강의에 사용된 교재 : [Computer Networking A Top-Down Approach 7th edition / Jim Kurose, Keith Ross]</span>
